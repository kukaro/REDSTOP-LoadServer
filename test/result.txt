실험조건은 윈도우와 리눅스는 데스크탑에서 진행했구요
보내는 데이터는 싱글 json파일입니다.
맥의 경우 제 노트북에서 실행헀는데... 값이 많이튀네요.
데스크탑은 값이 거의 튀지 않습니다.

맥의 cpu의 경우 4세대 i7이구요 2코어 4하이퍼스레드입니다.
윈도우와 리눅스 cpu의 5세대 i5이구요 4코어 4하이퍼스레드입니다.

보내고 응답 받는 시간까지를 계산했습니다.
nodejs일반적인 callback으로 구현해서 마지막 콜백이 끝나는 순간을 계산했습니다.
go의 경우 갯수만큼 고루틴 생성해서 구현했습니다.
고정 갯수로 테스트를 해봤지만 경우의 수가 너무 많아서 제외했습니다.
라이브러리는 각 언어에서 제공하는 기본 http를 사용했습니다.
echo와 express를 각각 프레임워크로 썻지만 호출시에는 기본을 사용했습니다.

총 20번 테스트를 해서 평균값을 확인했습니다.
호출횟수는 10만번 입니다.
명시적으로 갯수가 언급됬다면 10만번 호출한건 아닙니다.
단위는 ms입니다.

맥 인텔 4세대 i7(저전력) 2코어 4하이퍼스레드
nodejs의 평균값은 약 3만 정도이며
최소값으로는 1만2천, 최대값으로는 10만가량도 나옵니디.
300개를 기점으로 go와 비슷해지며 뒤로 갈수록 추월합니다.
go의 경우 평균값은 약 15만 정도이며
최소 값으로는 6만, 최대값으로는 28만입니다.
300개 이하에서는 node보다 빠르지만 기점으로 큰 낙폭으로 뒤집힙니다.

윈도우 인텔 5세대 i5(고전력) 4코어 4하이퍼스레드
nodejs의 평균값은 약 11,000 정도이며
최소값으로는 9,000, 최대값으로는 13,000입니다.
go의 평균값은 약 5,000 정도이며
최소값은 3,000, 최대값은 10,000 나옵니다.
어느 구간에서도 뒤집히지 않습니다.

리눅스(우분투, 데스크탑KDE) 인텔 5세대 i5(고전력) 4코어 4하이퍼스레드
nodejs의 평균값은 약 40,000 정도이며
최소값으로는 16,000, 최대값으로는 45,000입니다.
go의 평균값은 약 10,000 정도이며
최소값은 7,700, 최대값은 13,000입니다.

요약
맥-값이 많이 튀지만 체감상으로도 실제로도 nodejs가 많이 빠르다.
윈도우-맥보다도,리눅스보다도 성능이 좋은데 go가 nodejs보다 많이 빠르다.
리눅스-go가 nodejs보다 많이 빠르다.

문제점
튀는값에대한 처리를 잘못하겠습니다.
특히 맥에서는 너무 튀어서 저걸 평균내야하나 싶은 값들이 많았구요.
그리고 호출돌아오는데 시간이 너무 오래걸려서 데이터 받는데만 3시간 가량 써서 다시 테스트할때는 좀더 자동화해야할거 같에요.
변수를 줄이려면 어떻게 해야하는지를 잘 모르겠습니다. 이유는 모르겠는데 성능이 맥이 좀 딸리는걸 고려해도 병목이 너무 심합니다.
근데 일반적인 고전력상황에서 풀 성능을 내는 윈도우와 리눅스 캐이스에서는 go가 확실히 더빠릅니다.
고루틴을 안쓰면 메모리가 터지던데 어떻게 처리해야할지 잘모르겠어요.